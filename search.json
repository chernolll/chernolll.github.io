[{"title":"mapboxgl实时更新10w点","url":"/2025/08/08/mapboxgl%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B010w%E7%82%B9/","content":"&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;    &lt;title&gt;Mapbox GL | 10万点实时颜色更新&lt;/title&gt;    &lt;link      href=&quot;https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css&quot;      rel=&quot;stylesheet&quot;    /&gt;    &lt;script src=&quot;https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js&quot;&gt;&lt;/script&gt;    &lt;style&gt;      html,      body,      #map &#123;        height: 100%;        margin: 0;      &#125;      #panel &#123;        position: absolute;        top: 10px;        left: 10px;        z-index: 10;        background: rgba(0, 0, 0, 0.6);        color: white;        padding: 10px;        border-radius: 8px;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;map&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;panel&quot;&gt;10万点，颜色实时更新（feature-state）&lt;/div&gt;    &lt;script&gt;      mapboxgl.accessToken =        &quot;pk.eyJ1Ijoic3NpdmFsZW4iLCJhIjoiY205N3J1OWw5MGFoNzJscHQ2cjA1N21qcCJ9.KA0V5-Mh_KCV4DV5HkpAeg&quot;;      const map = new mapboxgl.Map(&#123;        container: &quot;map&quot;,        style: &quot;mapbox://styles/mapbox/dark-v11&quot;,        center: [116.397, 39.908],        zoom: 9,        renderWorldCopies: false,      &#125;);      map.on(&quot;load&quot;, () =&gt; &#123;        // 1. 添加 source，使用 promoteId        map.addSource(&quot;points&quot;, &#123;          type: &quot;geojson&quot;,          data: &#123; type: &quot;FeatureCollection&quot;, features: [] &#125;,          promoteId: &quot;id&quot;,          cluster: false,        &#125;);        // 2. 添加图层，颜色用 feature-state.v        map.addLayer(&#123;          id: &quot;points-layer&quot;,          type: &quot;circle&quot;,          source: &quot;points&quot;,          paint: &#123;            &quot;circle-color&quot;: [              &quot;interpolate&quot;,              [&quot;linear&quot;],              [&quot;coalesce&quot;, [&quot;feature-state&quot;, &quot;v&quot;], 0], // state.v不存在时用0              0.0,              &quot;#2DC4B2&quot;,              0.25,              &quot;#3BB3C3&quot;,              0.5,              &quot;#669EC4&quot;,              0.75,              &quot;#8B88B6&quot;,              1.0,              &quot;#A2719B&quot;,            ],            &quot;circle-radius&quot;: [              &quot;let&quot;,              &quot;r&quot;,              [&quot;coalesce&quot;, [&quot;get&quot;, &quot;r&quot;], 2],              [                &quot;interpolate&quot;,                [&quot;linear&quot;],                [&quot;zoom&quot;],                3,                [&quot;*&quot;, [&quot;var&quot;, &quot;r&quot;], 0.7],                12,                [&quot;*&quot;, [&quot;var&quot;, &quot;r&quot;], 1.4],              ],            ],            &quot;circle-opacity&quot;: 0.8,          &#125;,        &#125;);        // 3. 生成 10 万点数据（带 id）        const N = 100000;        const features = [];        for (let i = 0; i &lt; N; i++) &#123;          features.push(&#123;            type: &quot;Feature&quot;,            id: i, // id 字段，与 promoteId 对应            properties: &#123; id: i &#125;,            geometry: &#123;              type: &quot;Point&quot;,              coordinates: [                116.0 + Math.random(), // 经度                39.5 + Math.random(), // 纬度              ],            &#125;,          &#125;);        &#125;        map          .getSource(&quot;points&quot;)          .setData(&#123; type: &quot;FeatureCollection&quot;, features &#125;);        // 4. 模拟实时颜色更新（每帧改 2000 个点）        function randomUpdate() &#123;          for (let k = 0; k &lt; 2000; k++) &#123;            const id = Math.floor(Math.random() * N);            const v = Math.random();            map.setFeatureState(&#123; source: &quot;points&quot;, id &#125;, &#123; v &#125;);          &#125;          requestAnimationFrame(randomUpdate);        &#125;        randomUpdate();        // 如果是 WebSocket，直接在 onmessage 里调用 setFeatureState(&#123;source:&#x27;points&#x27;,id&#125;,&#123;v&#125;)      &#125;);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n","tags":["mapboxgl"]},{"title":"文字雨效果原理解析与实现","url":"/2025/08/11/canvas-%E6%96%87%E5%AD%97%E9%9B%A8/","content":"\n“雨点般的字符落下，像《黑客帝国》里的数字世界在流动。”本文将带你从 0 到 1 实现一个 Canvas 文字雨效果，并深入解析它的动画原理。\n\n效果预览\n核心代码/** @type &#123;HTMLCanvasElement&#125; */const canvas = document.querySelector(&quot;#canvas&quot;);const ctx = canvas.getContext(&quot;2d&quot;);const ratio = window.devicePixelRatio;const w = window.innerWidth * ratio;const h = window.innerHeight * ratio;canvas.width = w;canvas.height = h;const fontSize = 10 * ratio;ctx.font = `$&#123;fontSize&#125;px &quot;Roboto Mono&quot;`;const columnCount = Math.floor(w / fontSize);const charIndex = new Array(columnCount).fill(0);function getRandomChar() &#123;  const str = &quot;0123456789abcdefghijklmnopqrltuvwxyz&quot;;  return str[Math.floor(Math.random() * str.length)];&#125;function draw() &#123;  // 1. 半透明幕布，让旧文字逐渐变暗  ctx.fillStyle = &quot;rgba(0, 0, 0, 0.1)&quot;;  ctx.fillRect(0, 0, w, h);  // 2. 画新文字  ctx.fillStyle = &quot;#6be445&quot;;  ctx.textBaseline = &quot;top&quot;;  for (let i = 0; i &lt; columnCount; i++) &#123;    const text = getRandomChar();    const x = i * fontSize;    const y = charIndex[i] * fontSize;    ctx.fillText(text, x, y);    if (y &gt; h &amp;&amp; Math.random() &gt; 0.99) &#123;      charIndex[i] = 0;    &#125; else &#123;      charIndex[i]++;    &#125;  &#125;  // 此处改为用setTimeout延迟执行，这样效果看起来好一点  window.setTimeout(draw, 50);  // requestAnimationFrame(draw);&#125;draw();\n\n原理解析文字雨的动画主要依赖两个关键技巧：\n1. 半透明幕布叠加每一帧先用 rgba(0,0,0,0.1) 这样的半透明颜色填充整个画布：\nctx.fillStyle = &quot;rgba(0, 0, 0, 0.1)&quot;;ctx.fillRect(0, 0, w, h);\n\n\n作用：不是一次性清空画布，而是让之前的内容逐渐变暗\n效果：形成“尾迹”，看起来像字符带着残影下落\n如果透明度&#x3D;1：旧内容会一次性消失，没有流动感\n\n2. 列位置与字符落下\n按列计算 columnCount，每列独立控制一个字符的纵向位置\n每一帧在该列的下一行绘制一个新字符\n当字符到底部后，以一定概率重新从顶部开始落下\n\n3. 颜色与字体\n绿色字符：ctx.fillStyle = &quot;#6be445&quot;\n单一字体：保证列宽和字符对齐\n可以改成任意字符集（比如日文假名、emoji）\n\n优化建议\n在高 DPI 屏幕上使用 window.devicePixelRatio，防止模糊\n控制 requestAnimationFrame 的绘制频率，降低 CPU 占用\n使用更高透明度（如 0.05）获得更长的尾迹效果\n\n总结文字雨的酷炫效果并不复杂，关键是半透明幕布 + 按列落下的字符逻辑。理解了这个原理，你还可以用它做星空、烟雾、粒子尾迹等各种特效。\n\n🎬 拓展阅读：\n\nMDN CanvasRenderingContext2D 文档\nrequestAnimationFrame\n\n","tags":["canvas"]},{"title":"mapbox篇-动态闪烁点与聚类动画效果","url":"/2025/07/31/mapbox%E7%AF%87-%E5%8A%A8%E6%80%81%E9%97%AA%E7%83%81%E7%82%B9%E4%B8%8E%E8%81%9A%E7%B1%BB%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/","content":"Mapbox GL 原生支持动态图标渲染，本篇通过一个最小可运行 HTML 示例展示了以下功能：\n\n自定义动画图标：动态闪烁的脉冲点；\n动态点聚类效果：颜色与半径随数量变化；\n纯原生 HTML 和 JavaScript，无需框架；\n支持海量点渲染与动画共存；\n\n🔍 核心功能解读🔴 动态闪烁点图标（Pulsing Dot）使用 map.addImage 添加一个动态生成的 Canvas 图标：\nconst pulsingDot = &#123;  width: size, height: size,  data: new Uint8Array(size * size * 4),  onAdd: function() &#123;    const canvas = document.createElement(&#x27;canvas&#x27;);    canvas.width = this.width;    canvas.height = this.height;    this.context = canvas.getContext(&#x27;2d&#x27;);  &#125;,  render: function() &#123;    const t = (performance.now() % 1000) / 1000;    const radius = size / 2 * 0.3;    const outerRadius = size / 2 * 0.7 * t + radius;    const ctx = this.context;    ctx.clearRect(0, 0, this.width, this.height);    // 扩散波纹    ctx.beginPath();    ctx.arc(size/2, size/2, outerRadius, 0, Math.PI * 2);    ctx.fillStyle = `rgba(255, 200, 200, $&#123;1 - t&#125;)`;    ctx.fill();    // 中心圆点    ctx.beginPath();    ctx.arc(size/2, size/2, radius, 0, Math.PI * 2);    ctx.fillStyle = &#x27;rgba(255, 100, 100, 1)&#x27;;    ctx.strokeStyle = &#x27;white&#x27;;    ctx.lineWidth = 2 + 2 * (1 - t);    ctx.fill();    ctx.stroke();    this.data = ctx.getImageData(0, 0, this.width, this.height).data;    map.triggerRepaint();    return true;  &#125;&#125;;\n这种方式可以动态渲染每一帧，并自动通知 Mapbox 重绘。\n🌐 动态聚类样式（点数越多越大&#x2F;越亮）通过 GeoJSON 聚类功能自动生成 point_count，再使用 step() 表达式实现样式渐变：\npaint: &#123;  &#x27;circle-color&#x27;: [    &#x27;step&#x27;, [&#x27;get&#x27;, &#x27;point_count&#x27;],    &#x27;#51bbd6&#x27;, 10, &#x27;#f1f075&#x27;, 30, &#x27;#f28cb1&#x27;  ],  &#x27;circle-radius&#x27;: [    &#x27;step&#x27;, [&#x27;get&#x27;, &#x27;point_count&#x27;],    15, 10, 25, 30, 35  ]&#125;\n\n⚙️ 性能优化建议避免地图上同时使用太多 pulsingDot 实例（推荐 ≤ 100）；\n聚类图层内部自动管理聚合点数量，可放心用于 10K 以上数据；\n若图层间数据动态更新频繁，推荐分图层渲染、定时更新；\n🧠 适用场景实时定位、物联网监控、车流分布\n雷达波、脉冲扫描动画模拟\n高并发数据展示场景（热力图替代方案）\n完整代码&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;title&gt;Mapbox GL 动画 MVP&lt;/title&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=1,user-scalable=no&quot;&gt;  &lt;link href=&quot;https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.css&quot; rel=&quot;stylesheet&quot;&gt;  &lt;script src=&quot;https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.js&quot;&gt;&lt;/script&gt;  &lt;style&gt;    body,html &#123; margin:0; padding:0; height:100% &#125;    #map &#123; position:absolute; top:0; bottom:0; width:100% &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;map&quot;&gt;&lt;/div&gt;&lt;script&gt;mapboxgl.accessToken = &#x27;YOUR_ACCESS_TOKEN&#x27;;const map = new mapboxgl.Map(&#123;  container: &#x27;map&#x27;, style: &#x27;mapbox://styles/mapbox/streets-v11&#x27;,  center: [116.397, 39.907], zoom: 10&#125;);// 动态闪烁点：pulsing dot 图标const size = 100;const pulsingDot = &#123;  width: size, height: size,  data: new Uint8Array(size * size * 4),  onAdd: function() &#123;    const canvas = document.createElement(&#x27;canvas&#x27;);    canvas.width = this.width; canvas.height = this.height;    this.context = canvas.getContext(&#x27;2d&#x27;);  &#125;,  render: function() &#123;    const t = (performance.now() % 1000) / 1000;    const radius = size / 2 * 0.3;    const outerRadius = size / 2 * 0.7 * t + radius;    const ctx = this.context;    ctx.clearRect(0, 0, this.width, this.height);    // 外圈波纹    ctx.beginPath();    ctx.arc(size/2, size/2, outerRadius, 0, Math.PI * 2);    ctx.fillStyle = `rgba(255, 200, 200, $&#123;1 - t&#125;)`;    ctx.fill();    // 中心闪烁点    ctx.beginPath();    ctx.arc(size/2, size/2, radius, 0, Math.PI * 2);    ctx.fillStyle = &#x27;rgba(255, 100, 100, 1)&#x27;;    ctx.strokeStyle = &#x27;white&#x27;;    ctx.lineWidth = 2 + 2 * (1 - t);    ctx.fill();    ctx.stroke();    this.data = ctx.getImageData(0, 0, this.width, this.height).data;    // 每帧重绘图标    map.triggerRepaint();    return true;  &#125;&#125;;map.on(&#x27;load&#x27;, () =&gt; &#123;  map.addImage(&#x27;pulsing-dot&#x27;, pulsingDot, &#123; pixelRatio: 2 &#125;);  map.addSource(&#x27;dot-point&#x27;, &#123;    type: &#x27;geojson&#x27;,    data: &#123;      type: &#x27;FeatureCollection&#x27;,      features: [&#123;        type:&#x27;Feature&#x27;,        geometry: &#123; type:&#x27;Point&#x27;, coordinates:[116.397,39.907] &#125;      &#125;]    &#125;  &#125;);  map.addLayer(&#123;    id: &#x27;layer-with-pulsing-dot&#x27;,    type: &#x27;symbol&#x27;,    source: &#x27;dot-point&#x27;,    layout: &#123; &#x27;icon-image&#x27;: &#x27;pulsing-dot&#x27; &#125;  &#125;);  // 群集点示例：动态聚类大小与颜色  map.addSource(&#x27;random-points&#x27;, &#123;    type: &#x27;geojson&#x27;,    data: generateRandomPoints(),    cluster: true,    clusterMaxZoom: 14,    clusterRadius: 50  &#125;);  map.addLayer(&#123;    id: &#x27;clusters&#x27;,    type: &#x27;circle&#x27;,    source: &#x27;random-points&#x27;,    filter: [&#x27;has&#x27;, &#x27;point_count&#x27;],    paint: &#123;      &#x27;circle-color&#x27;: [        &#x27;step&#x27;,[&#x27;get&#x27;,&#x27;point_count&#x27;], &#x27;#51bbd6&#x27;, 10, &#x27;#f1f075&#x27;, 30, &#x27;#f28cb1&#x27;      ],      &#x27;circle-radius&#x27;: [        &#x27;step&#x27;,[&#x27;get&#x27;,&#x27;point_count&#x27;], 15, 10, 25, 30, 35      ]    &#125;  &#125;);  map.addLayer(&#123;    id: &#x27;cluster-count&#x27;,    type: &#x27;symbol&#x27;,    source: &#x27;random-points&#x27;,    filter: [&#x27;has&#x27;, &#x27;point_count&#x27;],    layout: &#123; &#x27;text-field&#x27;: [&#x27;get&#x27;,&#x27;point_count&#x27;], &#x27;text-size&#x27;: 12 &#125;  &#125;);  map.addLayer(&#123;    id: &#x27;unclustered-point&#x27;,    type: &#x27;circle&#x27;,    source: &#x27;random-points&#x27;,    filter: [&#x27;!&#x27;, [&#x27;has&#x27;,&#x27;point_count&#x27;]],    paint: &#123;      &#x27;circle-color&#x27;: &#x27;#11b4da&#x27;,      &#x27;circle-radius&#x27;: 6,      &#x27;circle-stroke-width&#x27;: 1,      &#x27;circle-stroke-color&#x27;: &#x27;#fff&#x27;    &#125;  &#125;);&#125;);// 随机生成若干个点function generateRandomPoints() &#123;  const features = [];  for (let i = 0; i &lt; 2000; i++) &#123;    const lon = 116.2 + (Math.random() * 0.4);    const lat = 39.8 + (Math.random() * 0.4);    features.push(&#123;      type:&#x27;Feature&#x27;, geometry:&#123;type:&#x27;Point&#x27;, coordinates:[lon,lat]&#125;    &#125;);  &#125;  return &#123; type:&#x27;FeatureCollection&#x27;, features &#125;;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":["mapboxgl"]},{"title":"ts手写工具函数","url":"/2025/08/06/ts%E6%89%8B%E5%86%99%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/","content":"防抖export function debounce&lt;T extends (...args: any[]) =&gt; void&gt;(  fn: T,  delay: number): (...args: Parameters&lt;T&gt;) =&gt; void &#123;  let timer: ReturnType&lt;typeof setTimeout&gt; | null = null;  return function (...args: Parameters&lt;T&gt;) &#123;    if (timer) clearTimeout(timer);    timer = setTimeout(() =&gt; &#123;      fn(...args);    &#125;, delay);  &#125;;&#125;\n\n节流export function throttle&lt;T extends (...args: any[]) =&gt; void&gt;(  fn: T,  wait: number): (...args: Parameters&lt;T&gt;) =&gt; void &#123;  let lastTime = 0;  return function (...args: Parameters&lt;T&gt;) &#123;    const now = Date.now();    if (now - lastTime &gt;= wait) &#123;      lastTime = now;      fn(...args);    &#125;  &#125;;&#125;\n\n深拷贝 deepCloneexport function deepClone&lt;T&gt;(target: T, map = new WeakMap()): T &#123;  // 基础类型或函数直接返回  if (typeof target !== &#x27;object&#x27; || target === null) return target;  // 已处理过的对象，直接返回以防循环引用  if (map.has(target)) return map.get(target);  let clone: any;  const Constructor = (target as any).constructor;  switch (Constructor) &#123;    case Date:      clone = new Date((target as unknown as Date).getTime());      break;    case RegExp:      clone = new RegExp((target as unknown as RegExp).source, (target as unknown as RegExp).flags);      break;    case Map:      clone = new Map();      map.set(target, clone);      (target as unknown as Map&lt;any, any&gt;).forEach((value, key) =&gt; &#123;        clone.set(deepClone(key, map), deepClone(value, map));      &#125;);      return clone;    case Set:      clone = new Set();      map.set(target, clone);      (target as unknown as Set&lt;any&gt;).forEach((value) =&gt; &#123;        clone.add(deepClone(value, map));      &#125;);      return clone;    default:      clone = Array.isArray(target) ? [] : &#123;&#125;;      map.set(target, clone);      for (const key in target) &#123;        if (Object.prototype.hasOwnProperty.call(target, key)) &#123;          clone[key] = deepClone((target as any)[key], map);        &#125;      &#125;      return clone;  &#125;  map.set(target, clone);  return clone;&#125;","tags":["typescript"]},{"title":"TypeScript 实现通用函数柯里化（支持类型推导）","url":"/2025/07/25/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/","content":"柯里化（Currying）是函数式编程中的一个重要概念，它指的是将一个多参数函数转换成一系列接收单个参数的函数，每次调用只处理一个参数，直到接收完所有参数并执行函数。\n在 javascript 中，lodash 等函数工具库提供了 _.curry 方法。但今天我们不使用库，而是用 TypeScript 实现一个具备完整类型推导的通用 curry 函数。\n\n.mermaid {\n  display: flex;\n  justify-content: center;\n  margin: 2em 0;\n}\n\n\ngraph TD\n  A[原始函数] --> B[函数定义]\n  A --> C[参数传递流程]\n  B --> D[\"function f(a: A, b: B, c: C)\"]\n  C --> E[\"a: A\"]\n  C --> F[\"(b: B)\"]\n  C --> G[\"(c: C)\"]\n\n\n\n🔍 使用场景举例举个例子，如果我们有这样一个函数：\nfunction a(age: number, name: string, gender: 0 | 1) &#123;  return `$&#123;name&#125; is $&#123;age&#125; years old, gender: $&#123;gender === 0 ? &#x27;Female&#x27; : &#x27;Male&#x27;&#125;`;&#125;````我们希望可以这样调用它：```tsconst curried = curry(a);const step1 = curried(23);         // 推导为 (name: string) =&gt; ...const step2 = step1(&#x27;Alice&#x27;);      // 推导为 (gender: 0 | 1) =&gt; ...const result = step2(0);           // 最终 result 是 string 类型\n\n\n✅ 最终实现这段代码的关键有两个部分：\n\n类型定义：我们要让 TypeScript 能够自动推导每一层参数的类型；\n运行时逻辑：要在每次调用时判断参数是否收集完，若未完成，则返回下一个函数。\n\n完整代码如下：\n// 类型定义type Curried&lt;A extends any[], R&gt; =   A extends [] ? () =&gt; R :  A extends [infer F] ? (x: F) =&gt; R :  A extends [infer F, ...infer Rest] ? (x: F) =&gt; Curried&lt;Rest, R&gt; :  never;// 函数实现function curry&lt;A extends any[], R&gt;(fn: (...args: A) =&gt; R): Curried&lt;A, R&gt; &#123;  return function curried(...args: any[]): any &#123;    if (args.length &gt;= fn.length) &#123;      return fn(...args as A);    &#125; else &#123;      return (...next: any[]) =&gt; curried(...args, ...next);    &#125;  &#125; as Curried&lt;A, R&gt;;&#125;\n\n\n注意：as Curried&lt;A, R&gt; 是关键的一步类型断言，用于让最终返回值拥有正确的类型提示。\n\n\n🧠 类型推导原理解析我们来看 Curried 的类型定义：\ntype Curried&lt;A extends any[], R&gt; =   A extends [] ? () =&gt; R :  A extends [infer F] ? (x: F) =&gt; R :  A extends [infer F, ...infer Rest] ? (x: F) =&gt; Curried&lt;Rest, R&gt; :  never;\n\n\nA 是一个参数数组类型，例如 [number, string, boolean]。\n如果是空数组，返回 () =&gt; R。\n如果是一个参数，返回 (x: 参数类型) =&gt; R。\n否则递归返回 (x: 第一个参数) =&gt; 柯里化剩下的参数。\n\n这就实现了类型层面上的“参数分发”。\n\n🚀 使用示例我们再回头看看最初的示例，看看 TypeScript 能否正确推导类型：\nfunction a(age: number, name: string, gender: 0 | 1) &#123;  return `$&#123;name&#125; is $&#123;age&#125; years old, gender: $&#123;gender === 0 ? &#x27;Female&#x27; : &#x27;Male&#x27;&#125;`;&#125;const curried = curry(a);const fn1 = curried(18);         // 推导为 (name: string) =&gt; ...const fn2 = fn1(&#x27;Bob&#x27;);          // 推导为 (gender: 0 | 1) =&gt; ...const result = fn2(1);           // 推导为 stringconsole.log(result); // &quot;Bob is 18 years old, gender: Male&quot;\n\nTypeScript 全程都能正确提示参数类型 ✅。\n\n🧩 补充思考：柯里化的意义？柯里化的一个常见用途是参数复用和函数组合：\nconst withAge18 = curried(18);const withAge18AndNameTom = withAge18(&#x27;Tom&#x27;);console.log(withAge18AndNameTom(0)); // &quot;Tom is 18 years old, gender: Female&quot;\n\n这种“预设部分参数”的方式，在表单处理、配置函数、事件绑定等场景中很有用。\n\n🧱 总结\n我们实现了一个支持完整类型推导的 curry 函数；\n利用了 TypeScript 的条件类型、递归类型等高级技巧；\n在多个参数的函数中，也能逐层传参并得到良好的类型提示；\n柯里化是函数式编程的重要组成部分，在实际开发中也有不少落地场景。\n\n如果你觉得有用，不妨点赞 + 收藏，一起探索更多 TypeScript 魔法 ✨\n","tags":["typescript","函数式编程","柯里化","高阶函数"]},{"title":"协变与逆变","url":"/2025/07/26/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98/","content":"协变（Covariance）简单说，协变表示类型在某个方向上保持“越具体越好”的兼容性。\n在 TypeScript 中，返回值类型是协变的：\ntype Animal = &#123; name: string &#125;type Dog = &#123; name: string; bark: () =&gt; void &#125;let getAnimal: () =&gt; Animallet getDog: () =&gt; DoggetAnimal = getDog // ✅ 合法getDog = getAnimal // ❌ 报错\n\n解释一下：\n\ngetDog 返回的是更具体的类型（Dog），赋值给返回类型是 Animal 的 getAnimal 是没问题的；\n反过来则不行，因为 getAnimal 可能返回一只猫，你不能假设它一定会 bark()。\n\n这就是协变：返回值可以更具体，但不能更泛化。\n逆变（Contravariance）逆变是参数类型的行为，和协变正好相反：越泛化越安全。\ntype Animal = &#123; name: string &#125;type Dog = &#123; name: string; bark: () =&gt; void &#125;let handleAnimal: (a: Animal) =&gt; voidlet handleDog: (d: Dog) =&gt; voidhandleDog = handleAnimal // ✅ 合法handleAnimal = handleDog // ❌ 报错\n\n解释：\n\nhandleAnimal 能处理所有动物，当然也能处理狗。\n但 handleDog 只会处理会叫的狗，万一你传进去一只猫，它不会 bark() 就炸了。\n\n这就是逆变：参数类型越宽泛，越保险。\nTips\n如果实在记不住，就这么记：返回值协变，参数逆变\nTypeScript 实际上在函数参数的逆变判断上有点“宽松”（默认是双向协变），但开启 strictFunctionTypes 后才是“标准模式”\nArray&lt;T&gt; 是协变的（因为只读），但 T[] 是不完全协变的（因为可以写）\n\n最后搞懂协变&#x2F;逆变，本质是在理解“类型的替换是否安全”这个事。不是晦涩的概念，而是类型系统背后的安全保障。\n如果你经常写泛型函数、封装库、或者用第三方复杂类型推导，理解它们会让你更放心地“放类型飞”。\n","tags":["typescript"]},{"title":"用ts构建长属性列表","url":"/2025/07/09/%E7%94%A8ts%E6%9E%84%E5%BB%BA%E9%95%BF%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8/","content":"解决方案type Fields&lt;Count = 0, Props extends string[] = []&gt; = Props[&#x27;length&#x27;] extends Count ? Props[number]: Fields&lt;Count, [...Props, `ad_$&#123;Props[&#x27;length&#x27;]&#125;`]&gt;;type SensorInfo  =&#123;  [K in Fields&lt;31&gt;]: number;&#125;\n","tags":["typescript","前端"]},{"title":"解析tiff","url":"/2025/07/16/%E8%A7%A3%E6%9E%90tiff/","content":"核心原理和流程读取文件缓冲区const buffer = fs.readFileSync(filePath);const tiff = await GeoTIFF.fromArrayBuffer(buffer.buffer);const image = await tiff.getImage();\n\n\n用 fs.readFileSync 同步读取整个 .tif/.tiff 二进制内容到内存。\nGeoTIFF.fromArrayBuffer 将这个二进制数据解析成一个 TIFF 对象，内部会读取 TIFF 头、IFD（图像文件目录）等结构。\ngetImage() 拿到第一个影像帧（TIFF 可以包含多帧，但我们通常只关心第一个图层）。\n\n获取栅格尺寸const width = image.getWidth();const height = image.getHeight();\n\n\n直接从 TIFF 元数据里读出栅格宽高，用于后续的像素遍历和画布创建。\n\n解析地理参考信息（TiePoints + PixelScale）const tiePoints = image.getTiePoints();const scale = image.getFileDirectory().ModelPixelScale;const originX = tiePoints[0].x;const originY = tiePoints[0].y;const [pixelSizeX, pixelSizeY] = scale;\n\n\nTiePoints：一对或多对像素坐标 ↔ 地理坐标（通常只有一对），告诉我们影像左上角（或某个像素）的地图投影坐标。\nModelPixelScale：每个像素在投影坐标系下的真实长度（X、Y 方向）。\n由此，就能算出整张影像在投影坐标系下的边界：- 左下角 (minX, minY)- 右上角 (maxX, maxY)\n\n读取投影（EPSG）信息const geoKeys = image.getGeoKeys();const epsgCode = geoKeys.ProjectedCSTypeGeoKey || geoKeys.GeographicTypeGeoKey;const sourceCrs = `EPSG:$&#123;epsgCode&#125;`;\n\n\nGeoKeys 中存着 TIFF 里记录的投影代码，比如 3857、4326 等。\n拼成 EPSG:XXXX 字符串，方便后续用 proj4 做坐标转换。\n\n投影坐标 → 地理坐标（经纬度）const transformer = proj4(sourceCrs, &quot;EPSG:4326&quot;);const [minLon, minLat] = transformer.forward([minX, minY]);const [maxLon, maxLat] = transformer.forward([maxX, maxY]);\n\n\n用 proj4 在不同 CRS（如 WebMercator、UTM）之间无缝投影转换。\n将四个角的投影坐标转换到 WGS84（EPSG:4326）下的经纬度。\n\n读取像素栅格并准备渲染const rasters = await image.readRasters(&#123; interleave: true &#125;);const rasterData = rasters instanceof Uint8ClampedArray  ? rasters  : new Uint8ClampedArray(rasters as unknown as Uint8Array);\n\n\nreadRasters(&#123; interleave: true &#125;) 会一次性拿到所有波段数据并按 RGBA、灰度等格式排列。\nCanvas 的 ImageData 要求底层数据是 Uint8ClampedArray，所以这里做了类型兼容转换。\n\n在 Canvas 上绘制栅格const canvas = createCanvas(width, height);const ctx = canvas.getContext(&quot;2d&quot;);const imgData = ctx.createImageData(width, height);imgData.data.set(rasterData);ctx.putImageData(imgData, 0, 0);\n\n\ncreateCanvas 根据影像尺寸新建内存画布。\n用 createImageData 新建一个空白的像素缓冲区，data.set(...) 将栅格数据写入，再一口气绘制到画布。\n\n导出为图片文件const outPath = filePath.replace(/\\.(tif|tiff)$/i, &quot;.png&quot;);fs.writeFileSync(outPath, canvas.toBuffer(&quot;image/png&quot;));fs.writeFileSync(outPath, webpBuffer);\n\n\ncanvas.toBuffer(&#39;image/png&#39;) 会调用底层的图像库（如 libvips 或 Cairo）将画布内容编码为 PNG 格式。\n最后写磁盘生成 .png 文件。\n\n返回综合元信息return &#123;  width,  height,  sourceCrs,  bboxSource: &#123; minX, minY, maxX, maxY &#125;,  bboxLatLng: &#123; minLat, minLon, maxLat, maxLon &#125;,  geoKeys,  webp: outPath,&#125;;\n\n\n将所有关键信息（原始投影坐标边界、地理坐标边界、输出文件路径等）打包返回，方便后续自动化流水线使用或记录。\n\n\n核心思路：\n解析 TIFF 元数据 获取投影、地理定位信息（TiePoints + Scale + GeoKeys）；\n转换坐标 得到人类易读的经纬度；\n读取并可视化影像 构建 Canvas，渲染成标准图像格式；\n输出文件和元数据 供后续使用。\n\n这样，你就能在纯 Node.js 环境下，实现对任何 GeoTIFF 文件的“读投影、算范围、出图片”这一整套流程。\n\n完整代码/* * Node.js script to read a GeoTIFF (.tif/.tiff), extract its projection, * compute geographic bounding box, and render the raster to a PNG image. * * Dependencies: *   npm install geotiff proj4 canvas */import fs from &#x27;fs&#x27;;import * as GeoTIFF from &#x27;geotiff&#x27;;import proj4 from &#x27;proj4&#x27;;import &#123; createCanvas &#125; from &#x27;canvas&#x27;;async function parseGeoTIFF(filePath: string) &#123;  // 1. Read file into buffer  const buffer = fs.readFileSync(filePath);  // 2. Parse the GeoTIFF  const tiff = await GeoTIFF.fromArrayBuffer(buffer.buffer);  const image = await tiff.getImage();  // 3. Image dimensions  const width = image.getWidth();  const height = image.getHeight();  // 4. Geo tie points &amp; pixel scale  const tiePoints = image.getTiePoints();  const scale = image.getFileDirectory().ModelPixelScale;  if (!tiePoints.length || !scale) &#123;    throw new Error(&#x27;Missing geo-referencing tags (tie points or pixel scale)&#x27;);  &#125;  const &#123; x: originX, y: originY &#125; = tiePoints[0];  const [pixelSizeX, pixelSizeY] = scale;  // 5. Compute bounding box in source CRS  const minX = originX;  const maxY = originY;  const maxX = originX + width * pixelSizeX;  const minY = originY - height * pixelSizeY;  // 6. Projection info (EPSG code)  const geoKeys = image.getGeoKeys();  const epsgCode = geoKeys.ProjectedCSTypeGeoKey || geoKeys.GeographicTypeGeoKey;  const sourceCrs = EPSG:$&#123;epsgCode&#125;;  // 7. Transform corners to WGS84 (lat/lon)  const transformer = proj4(sourceCrs, &#x27;EPSG:4326&#x27;);  const [minLon, minLat] = transformer.forward([minX, minY]);  const [maxLon, maxLat] = transformer.forward([maxX, maxY]);  // 8. Read raster data (interleaved)  const rastersRaw = await image.readRasters(&#123; interleave: true &#125;);  // Convert to Uint8ClampedArray for ImageData  const rasterData =    rastersRaw instanceof Uint8ClampedArray      ? rastersRaw      : new Uint8ClampedArray(rastersRaw as any);  // 9. Render to canvas  const canvas = createCanvas(width, height);  const ctx = canvas.getContext(&#x27;2d&#x27;);  const imgData = ctx.createImageData(width, height);  imgData.data.set(rasterData);  ctx.putImageData(imgData, 0, 0);  // 10. Save PNG  const outPath = filePath.replace(/\\.(tif|tiff)$/i, &#x27;.png&#x27;);  fs.writeFileSync(outPath, canvas.toBuffer(&#x27;image/png&#x27;));  // 11. Return metadata  return &#123;    width,    height,    sourceCrs,    bboxSource: &#123; minX, minY, maxX, maxY &#125;,    bboxLatLng: &#123; minLat, minLon, maxLat, maxLon &#125;,    geoKeys,    png: outPath  &#125;;&#125;// Example usage:(async () =&gt; &#123;  try &#123;    const result = await parseGeoTIFF(process.argv[2]);    console.log(&#x27;Parsed GeoTIFF metadata:&#x27;);    console.log(JSON.stringify(result, null, 2));  &#125; catch (err) &#123;    console.error(&#x27;Error parsing GeoTIFF:&#x27;, err);  &#125;&#125;)();\n","tags":["GIS","tiff"]}]