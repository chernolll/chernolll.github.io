[{"title":"AI-prompt","url":"/2025/07/16/AI-prompt/","content":"提问模板角色设定：请你以「资深前端专家」的身份回答。背景与技术栈：- 项目使用：Vue 3 + TypeScript + MapboxGL- 运行环境：Chrome 最新，Node 14- 已尝试：在 mounted 钩子中初始化地图，但缩放事件触发不稳定核心需求：- 实现地图在折叠面板中可正常渲染并自适应大小- 面板收起/展开后能自动调用 map.resize()期望输出：1. 最佳实践的代码示例2. 关键点解读（为什么这样写，核心原理）3. 注意事项或坑点附加要求：- 代码风格请简洁、注释清晰- 如果有第三方包推荐，请说明理由\n\n前端# 资深前端开发专家prompt1. 资深前端开发专家；2. 精通各种前端框架及技术栈；3. 精通GIS开发，比如Cesium、OpenLayers、MapboxGL等；4. 同时也精通桌面端开发，比如electron；5. 对计算机网络、操作系统、数据结构与算法有着非常深的见解；6. 擅长教学、带新人，能很好的引导新人学习与了解业务； 7. 基本上市面上的前端技术栈和业务类型你都深入了解过，并且也熟悉golang和nodejs后端服务；\n\n职场# 猎头prompt1. 你是一个资深的职场猎头，对于职场的一些生存规则、求职者的入职标准非常了解；2. 现在我是一个普通的打工人（前端开发工程师），我会对你咨询一些问题，希望你能帮助我；3. 每当你帮我解决一个问题，你都会非常愉悦"},{"title":"用ts构建长属性列表","url":"/2025/07/09/%E7%94%A8ts%E6%9E%84%E5%BB%BA%E9%95%BF%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8/","content":"解决方案type Fields&lt;Count = 0, Props extends string[] = []&gt; = Props[&#x27;length&#x27;] extends Count ? Props[number]: Fields&lt;Count, [...Props, `ad_$&#123;Props[&#x27;length&#x27;]&#125;`]&gt;;type SensorInfo  =&#123;  [K in Fields&lt;31&gt;]: number;&#125;\n","tags":["typescript","前端"]},{"title":"TypeScript 实现通用函数柯里化（支持类型推导）","url":"/2025/07/25/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/","content":"柯里化（Currying）是函数式编程中的一个重要概念，它指的是将一个多参数函数转换成一系列接收单个参数的函数，每次调用只处理一个参数，直到接收完所有参数并执行函数。\n在 JavaScript 中，lodash 等函数工具库提供了 _.curry 方法。但今天我们不使用库，而是用 TypeScript 实现一个具备完整类型推导的通用 curry 函数。\n\n.mermaid {\n  display: flex;\n  justify-content: center;\n  margin: 2em 0;\n}\n\n\ngraph TD\n  A[原始函数] --> B[函数定义]\n  A --> C[参数传递流程]\n  B --> D[\"function f(a: A, b: B, c: C)\"]\n  C --> E[\"a: A\"]\n  C --> F[\"(b: B)\"]\n  C --> G[\"(c: C)\"]\n\n\n\n🔍 使用场景举例举个例子，如果我们有这样一个函数：\nfunction a(age: number, name: string, gender: 0 | 1) &#123;  return `$&#123;name&#125; is $&#123;age&#125; years old, gender: $&#123;gender === 0 ? &#x27;Female&#x27; : &#x27;Male&#x27;&#125;`;&#125;````我们希望可以这样调用它：```tsconst curried = curry(a);const step1 = curried(23);         // 推导为 (name: string) =&gt; ...const step2 = step1(&#x27;Alice&#x27;);      // 推导为 (gender: 0 | 1) =&gt; ...const result = step2(0);           // 最终 result 是 string 类型\n\n\n✅ 最终实现这段代码的关键有两个部分：\n\n类型定义：我们要让 TypeScript 能够自动推导每一层参数的类型；\n运行时逻辑：要在每次调用时判断参数是否收集完，若未完成，则返回下一个函数。\n\n完整代码如下：\n// 类型定义type Curried&lt;A extends any[], R&gt; =   A extends [] ? () =&gt; R :  A extends [infer F] ? (x: F) =&gt; R :  A extends [infer F, ...infer Rest] ? (x: F) =&gt; Curried&lt;Rest, R&gt; :  never;// 函数实现function curry&lt;A extends any[], R&gt;(fn: (...args: A) =&gt; R): Curried&lt;A, R&gt; &#123;  return function curried(...args: any[]): any &#123;    if (args.length &gt;= fn.length) &#123;      return fn(...args as A);    &#125; else &#123;      return (...next: any[]) =&gt; curried(...args, ...next);    &#125;  &#125; as Curried&lt;A, R&gt;;&#125;\n\n\n注意：as Curried&lt;A, R&gt; 是关键的一步类型断言，用于让最终返回值拥有正确的类型提示。\n\n\n🧠 类型推导原理解析我们来看 Curried 的类型定义：\ntype Curried&lt;A extends any[], R&gt; =   A extends [] ? () =&gt; R :  A extends [infer F] ? (x: F) =&gt; R :  A extends [infer F, ...infer Rest] ? (x: F) =&gt; Curried&lt;Rest, R&gt; :  never;\n\n\nA 是一个参数数组类型，例如 [number, string, boolean]。\n如果是空数组，返回 () =&gt; R。\n如果是一个参数，返回 (x: 参数类型) =&gt; R。\n否则递归返回 (x: 第一个参数) =&gt; 柯里化剩下的参数。\n\n这就实现了类型层面上的“参数分发”。\n\n🚀 使用示例我们再回头看看最初的示例，看看 TypeScript 能否正确推导类型：\nfunction a(age: number, name: string, gender: 0 | 1) &#123;  return `$&#123;name&#125; is $&#123;age&#125; years old, gender: $&#123;gender === 0 ? &#x27;Female&#x27; : &#x27;Male&#x27;&#125;`;&#125;const curried = curry(a);const fn1 = curried(18);         // 推导为 (name: string) =&gt; ...const fn2 = fn1(&#x27;Bob&#x27;);          // 推导为 (gender: 0 | 1) =&gt; ...const result = fn2(1);           // 推导为 stringconsole.log(result); // &quot;Bob is 18 years old, gender: Male&quot;\n\nTypeScript 全程都能正确提示参数类型 ✅。\n\n🧩 补充思考：柯里化的意义？柯里化的一个常见用途是参数复用和函数组合：\nconst withAge18 = curried(18);const withAge18AndNameTom = withAge18(&#x27;Tom&#x27;);console.log(withAge18AndNameTom(0)); // &quot;Tom is 18 years old, gender: Female&quot;\n\n这种“预设部分参数”的方式，在表单处理、配置函数、事件绑定等场景中很有用。\n\n🧱 总结\n我们实现了一个支持完整类型推导的 curry 函数；\n利用了 TypeScript 的条件类型、递归类型等高级技巧；\n在多个参数的函数中，也能逐层传参并得到良好的类型提示；\n柯里化是函数式编程的重要组成部分，在实际开发中也有不少落地场景。\n\n如果你觉得有用，不妨点赞 + 收藏，一起探索更多 TypeScript 魔法 ✨\n","tags":["typescript","函数式编程","柯里化","高阶函数"]},{"title":"解析tiff","url":"/2025/07/16/%E8%A7%A3%E6%9E%90tiff/","content":"核心原理和流程读取文件缓冲区   const buffer = fs.readFileSync(filePath);const tiff = await GeoTIFF.fromArrayBuffer(buffer.buffer);const image = await tiff.getImage();\n\n\n用 fs.readFileSync 同步读取整个 .tif/.tiff 二进制内容到内存。\nGeoTIFF.fromArrayBuffer 将这个二进制数据解析成一个 TIFF 对象，内部会读取 TIFF 头、IFD（图像文件目录）等结构。\ngetImage() 拿到第一个影像帧（TIFF 可以包含多帧，但我们通常只关心第一个图层）。\n\n获取栅格尺寸   const width = image.getWidth();const height = image.getHeight();\n\n\n直接从 TIFF 元数据里读出栅格宽高，用于后续的像素遍历和画布创建。\n\n解析地理参考信息（TiePoints + PixelScale）   const tiePoints = image.getTiePoints();const scale = image.getFileDirectory().ModelPixelScale;const originX = tiePoints[0].x;const originY = tiePoints[0].y;const [pixelSizeX, pixelSizeY] = scale;\n\n\nTiePoints：一对或多对像素坐标 ↔ 地理坐标（通常只有一对），告诉我们影像左上角（或某个像素）的地图投影坐标。\nModelPixelScale：每个像素在投影坐标系下的真实长度（X、Y 方向）。\n由此，就能算出整张影像在投影坐标系下的边界：- 左下角 (minX, minY)- 右上角 (maxX, maxY)\n\n读取投影（EPSG）信息   const geoKeys = image.getGeoKeys();const epsgCode = geoKeys.ProjectedCSTypeGeoKey || geoKeys.GeographicTypeGeoKey;const sourceCrs = `EPSG:$&#123;epsgCode&#125;`;\n\n\nGeoKeys 中存着 TIFF 里记录的投影代码，比如 3857、4326 等。\n拼成 EPSG:XXXX 字符串，方便后续用 proj4 做坐标转换。\n\n投影坐标 → 地理坐标（经纬度）   const transformer = proj4(sourceCrs, &#x27;EPSG:4326&#x27;);const [minLon, minLat] = transformer.forward([minX, minY]);const [maxLon, maxLat] = transformer.forward([maxX, maxY]);\n\n\n用 proj4 在不同 CRS（如 WebMercator、UTM）之间无缝投影转换。\n将四个角的投影坐标转换到 WGS84（EPSG:4326）下的经纬度。\n\n读取像素栅格并准备渲染   const rasters = await image.readRasters(&#123; interleave: true &#125;);const rasterData = rasters instanceof Uint8ClampedArray  ? rasters  : new Uint8ClampedArray(rasters as unknown as Uint8Array);\n\n\nreadRasters(&#123; interleave: true &#125;) 会一次性拿到所有波段数据并按 RGBA、灰度等格式排列。\nCanvas 的 ImageData 要求底层数据是 Uint8ClampedArray，所以这里做了类型兼容转换。\n\n在 Canvas 上绘制栅格   const canvas = createCanvas(width, height);const ctx = canvas.getContext(&#x27;2d&#x27;);const imgData = ctx.createImageData(width, height);imgData.data.set(rasterData);ctx.putImageData(imgData, 0, 0);\n\n\ncreateCanvas 根据影像尺寸新建内存画布。\n用 createImageData 新建一个空白的像素缓冲区，data.set(...) 将栅格数据写入，再一口气绘制到画布。\n\n导出为图片文件   const outPath = filePath.replace(/\\.(tif|tiff)$/i, &#x27;.png&#x27;);fs.writeFileSync(outPath, canvas.toBuffer(&#x27;image/png&#x27;));fs.writeFileSync(outPath, webpBuffer);\n\n\ncanvas.toBuffer(&#39;image/png&#39;) 会调用底层的图像库（如 libvips 或 Cairo）将画布内容编码为 PNG 格式。\n最后写磁盘生成 .png 文件。\n\n返回综合元信息   return &#123;  width, height,  sourceCrs,  bboxSource: &#123; minX, minY, maxX, maxY &#125;,  bboxLatLng: &#123; minLat, minLon, maxLat, maxLon &#125;,  geoKeys,  webp: outPath&#125;;\n\n\n将所有关键信息（原始投影坐标边界、地理坐标边界、输出文件路径等）打包返回，方便后续自动化流水线使用或记录。\n\n\n核心思路：\n解析 TIFF 元数据 获取投影、地理定位信息（TiePoints + Scale + GeoKeys）；\n转换坐标 得到人类易读的经纬度；\n读取并可视化影像 构建 Canvas，渲染成标准图像格式；\n输出文件和元数据 供后续使用。\n\n这样，你就能在纯 Node.js 环境下，实现对任何 GeoTIFF 文件的“读投影、算范围、出图片”这一整套流程。\n\n完整代码/* * Node.js script to read a GeoTIFF (.tif/.tiff), extract its projection, * compute geographic bounding box, and render the raster to a PNG image. * * Dependencies: *   npm install geotiff proj4 canvas */import fs from &#x27;fs&#x27;;import * as GeoTIFF from &#x27;geotiff&#x27;;import proj4 from &#x27;proj4&#x27;;import &#123; createCanvas &#125; from &#x27;canvas&#x27;;async function parseGeoTIFF(filePath: string) &#123;  // 1. Read file into buffer  const buffer = fs.readFileSync(filePath);  // 2. Parse the GeoTIFF  const tiff = await GeoTIFF.fromArrayBuffer(buffer.buffer);  const image = await tiff.getImage();  // 3. Image dimensions  const width = image.getWidth();  const height = image.getHeight();  // 4. Geo tie points &amp; pixel scale  const tiePoints = image.getTiePoints();  const scale = image.getFileDirectory().ModelPixelScale;  if (!tiePoints.length || !scale) &#123;    throw new Error(&#x27;Missing geo-referencing tags (tie points or pixel scale)&#x27;);  &#125;  const &#123; x: originX, y: originY &#125; = tiePoints[0];  const [pixelSizeX, pixelSizeY] = scale;  // 5. Compute bounding box in source CRS  const minX = originX;  const maxY = originY;  const maxX = originX + width * pixelSizeX;  const minY = originY - height * pixelSizeY;  // 6. Projection info (EPSG code)  const geoKeys = image.getGeoKeys();  const epsgCode = geoKeys.ProjectedCSTypeGeoKey || geoKeys.GeographicTypeGeoKey;  const sourceCrs = EPSG:$&#123;epsgCode&#125;;  // 7. Transform corners to WGS84 (lat/lon)  const transformer = proj4(sourceCrs, &#x27;EPSG:4326&#x27;);  const [minLon, minLat] = transformer.forward([minX, minY]);  const [maxLon, maxLat] = transformer.forward([maxX, maxY]);  // 8. Read raster data (interleaved)  const rastersRaw = await image.readRasters(&#123; interleave: true &#125;);  // Convert to Uint8ClampedArray for ImageData  const rasterData =    rastersRaw instanceof Uint8ClampedArray      ? rastersRaw      : new Uint8ClampedArray(rastersRaw as any);  // 9. Render to canvas  const canvas = createCanvas(width, height);  const ctx = canvas.getContext(&#x27;2d&#x27;);  const imgData = ctx.createImageData(width, height);  imgData.data.set(rasterData);  ctx.putImageData(imgData, 0, 0);  // 10. Save PNG  const outPath = filePath.replace(/\\.(tif|tiff)$/i, &#x27;.png&#x27;);  fs.writeFileSync(outPath, canvas.toBuffer(&#x27;image/png&#x27;));  // 11. Return metadata  return &#123;    width,    height,    sourceCrs,    bboxSource: &#123; minX, minY, maxX, maxY &#125;,    bboxLatLng: &#123; minLat, minLon, maxLat, maxLon &#125;,    geoKeys,    png: outPath  &#125;;&#125;// Example usage:(async () =&gt; &#123;  try &#123;    const result = await parseGeoTIFF(process.argv[2]);    console.log(&#x27;Parsed GeoTIFF metadata:&#x27;);    console.log(JSON.stringify(result, null, 2));  &#125; catch (err) &#123;    console.error(&#x27;Error parsing GeoTIFF:&#x27;, err);  &#125;&#125;)();\n","tags":["GIS","tiff"]}]